# 函数Function

## 了解函数

函数就是把特定功能的代码抽取出来并进行封装，用来重复执行一些功能，并起个名字（函数名）。函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行 

好处：函数可以重复执行某一部分代码（通过函数名调用）

​	   使程序变得更简短而清晰

​	    有利于程序维护

什么时候需要函数

​	当相同的代码出现多次

​	当需要提取公共代码时

## 函数的定义

### 1、声明式

利用关键字function定义

```
function show(){
	
}
```

函数的声明会提前 ==> 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）

### 2、赋值式

与变量声明一致，给变量赋值一个匿名函数

```
var show = function(){

}
```

匿名函数：没有名字的函数

## 函数的执行

### 1、手动执行（主动）

主动写一句代码执行，立即执行

```
函数名();
```

### 2、事件驱动（被动）

第一种

```
<button id="btn">事件驱动</button>
<script>
	var btn = docuement.getElementById('btn');
	btn.onclick = show;
</script>
```

第二种

```
<button id="btn">事件驱动</button>
<script>
	var btn = docuement.getElementById('btn');
	btn.onclick = function(){
        
	}
</script>
```

### 常用事件

onclick：点击事件

ondblclick：双击事件

onmouseover：鼠标移入事件

onmouseout：鼠标移开事件

onchange：内容改变事件（一般用于表单元素，修改后并失去焦点后执行）

onkeyup：键盘按键弹起事件

oninput：修改时执行

### 内置函数

js内部已经定义好的函数（直接调用，在任意位置使用）

## 声明提前

函数的声明提前

变量声明提前：声明但没有赋值的变量默认为undefined

## 浏览器如何执行js代码

1）声明提前（保存声明）：把变量声明，函数声明保存起来

​	提前到当前作用域

2）顺序：从上往下

## 作用域

变量的使用范围

### 全局作用域

在函数外

#### 全局变量

在全局作用域下声明的变量

### 局部作用域

在函数内

#### 局部变量

在局部作用域下声明的变量

### 变量访问规则

就近原则

当前作用域 > 上级作用 >... >全局作用域

如在某一作用域中作用，则停止查找

如到全局作用域还没找到，则报xxx is not defined

### 作用域链

当前作用域到全局作用域的链条

## 函数的参数

### 形参

函数定义时的参数

形参就是局部变量

### 实参

函数执行时的参数

```
function sum(a，b,c){
    //a为形参
    //内部自动声明局部变量 var a = 5
}
sum(5,10,15); //5为实参 10为实参 15为实参

sum(10,20);//实参数量 < 形参：多余的形参为undefiend

sum(1,2,3,4,5,6,7,8)//实参数量 > 形参：多余的实参被忽略
```

注：形参与实参的数量可以不同

### arguments

```
格式（数组）：[10,5]    

索引值index：从0开始的正整数

length：实参数量

获取其中某一个：arguments[index]
```

保存实参信息

只能在函数内使用

### 回调函数

引用数据类型与基本数据类型的传参（引用传递与值传递） 

​	函数作为参数传递

## 函数返回值

运算后得到的值

终止函数的执行（return后的代码不会被执行）

### return 

默认：返回undefined

后面带值：把值返回到函数执行的地方

函数内->函数外

## 函数中的this

函数中的this是一个关键字，表示当前对象（而当前对象是谁，取决于这个函数的执行环境）

### 指向

手动执行：window（全局作用域）

事件驱动：绑定事件的元素

## 递归

函数可以自己调用自己, 成为函数的递归调用 

递归函数中必须有跳出条件

递归调用的过程:

1. 首先去找临界值，即无需计算，获得的值(一般是返回该值)。
2. 找这一次和上一次的关系(一般从后往前找)
3. 假设当前函数已经可以使用，调用自身计算上一次的运行结果，再写出这次的运行结果。 